name: Update Game Data

on:
  workflow_dispatch:
  schedule:
    - cron: "0 17 * * *"  # 台灣 01:00（UTC+8）

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout repo
        uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install dependencies
        run: pip install requests pillow

      # 產生/覆蓋腳本（保留你原本流程；下面兩支已是防呆版）
      - name: Create scripts (in-memory)
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p scripts data assets/img

          # 映射檔若不存在，先建表頭
          [ -f data/mechanism_map_zh.csv ] || printf 'bgg_mechanism_en,mechanism_zh\n' > data/mechanism_map_zh.csv
          [ -f data/category_map_zh.csv ]  || printf 'bgg_category_en,category_zh\n'   > data/category_map_zh.csv

          # --- scripts/resolve_bgg.py ---
          cat <<'PY' > scripts/resolve_bgg.py
import csv, json, requests, xml.etree.ElementTree as ET
from pathlib import Path

MANUAL = Path("data/manual.csv")
OUT    = Path("data/bgg_ids.json")

def bgg_search_to_id(q: str):
    url = f"https://boardgamegeek.com/xmlapi2/search?type=boardgame&query={requests.utils.quote(q)}"
    r = requests.get(url, timeout=30)
    while r.status_code == 202:
        r = requests.get(url, timeout=30)
    r.raise_for_status()
    root = ET.fromstring(r.text)
    best = None
    for it in root.findall("item"):
        if it.get("type") != "boardgame":
            continue
        names = [n.get("value") for n in it.findall("name") if n.get("type") == "primary"]
        if names and names[0].lower() == q.lower():
            return int(it.get("id"))
        if best is None:
            best = int(it.get("id"))
    return best

def main():
    rows = []
    if not MANUAL.exists():
        OUT.write_text("[]", encoding="utf-8"); print("No manual.csv → 0"); return
    with MANUAL.open(encoding="utf-8-sig") as f:
        reader = csv.DictReader(f)
        for r in reader:
            entry = {k: r.get(k) for k in ["name_zh","name_en_override","alias_zh","category_zh","price_msrp_twd","price_twd","used_price_twd","price_note","used_note","manual_override","stock","description","image_override","image_version_id","bgg_id","bgg_query"] if k in r}
            bid = (r.get("bgg_id") or "").strip()
            q   = (r.get("bgg_query") or "").strip()
            if not bid and q:
                try: bid = bgg_search_to_id(q)
                except Exception: bid = None
            if bid: entry["bgg_id"] = int(bid)
            if q:   entry["bgg_query"] = q
            rows.append(entry)
    OUT.parent.mkdir(parents=True, exist_ok=True)
    OUT.write_text(json.dumps(rows, ensure_ascii=False, indent=2), encoding="utf-8")
    print(f"Resolved {len(rows)} entries → {OUT}")
if __name__ == "__main__": main()
PY

          # --- scripts/fetch_bgg.py（退避＋備援＋增量＋門檻） ---
          cat <<'PY' > scripts/fetch_bgg.py
import os, time, json, random
from pathlib import Path
import xml.etree.ElementTree as ET
import requests

IDS_FILE   = Path("data/bgg_ids.json")
OUT_FILE   = Path("data/bgg_data.json")
TMP_FILE   = Path("data/.bgg_data.tmp.json")

BATCH   = int(os.getenv("BGG_BATCH", "4"))
SLEEP   = float(os.getenv("BGG_SLEEP", "6.0"))
RETRY   = int(os.getenv("BGG_RETRY", "6"))
JITTER  = float(os.getenv("BGG_JITTER", "0.7"))
VERSIONS= os.getenv("BGG_VERSIONS", "0")
HOSTS   = [h.strip() for h in os.getenv("BGG_HOSTS", "api.geekdo.com,boardgamegeek.com").split(",")]
MIN_SAVE= int(os.getenv("BGG_MIN_SAVE", "50"))

UA = os.getenv("HTTP_UA", "Mozilla/5.0 (compatible; GameGuideBot/1.0)")
AC_LANG = os.getenv("HTTP_ACCEPT_LANGUAGE", "en-US,en;q=0.9")

def load_ids():
    data = json.loads(IDS_FILE.read_text(encoding="utf-8"))
    ids = []
    for x in data:
        v = x.get("bgg_id") if isinstance(x, dict) else x
        try:
            i = int(v)
            if i > 0: ids.append(i)
        except: pass
    return ids

def parse_xml(xml_text: str):
    root = ET.fromstring(xml_text)
    out = []
    def _to_float(v):
        try: return float(v) if v not in (None,"N/A","NaN") else None
        except: return None
    for it in root.findall("./item"):
        bid = int(it.get("id", "0") or "0")
        name_en = ""
        for nm in it.findall("./name"):
            if nm.get("type") == "primary":
                name_en = nm.get("value") or ""
                break
        image = (it.findtext("./image") or "").strip()
        thumb = (it.findtext("./thumbnail") or "").strip()
        # ratings
        ratings = it.find("statistics/ratings")
        avg = bayes = None; rank_overall = None
        if ratings is not None:
            a = ratings.find("average"); b = ratings.find("bayesaverage")
            avg   = _to_float(a.get("value")) if a is not None else None
            bayes = _to_float(b.get("value")) if b is not None else None
            ranks = ratings.find("ranks")
            if ranks is not None:
                for rk in ranks.findall("rank"):
                    if rk.get("id")=="1" or rk.get("name")=="boardgame":
                        rv = rk.get("value")
                        if rv not in (None,"Not Ranked","0","N/A"):
                            try: rank_overall = int(rv)
                            except: pass
                        break
        out.append({
            "bgg_id": bid,
            "name_en": name_en,
            "image_url": image or thumb,
            "thumb_url": thumb or image,
            "rating_avg": avg, "rating_bayes": bayes, "rank_overall": rank_overall
        })
    return out

def get_session():
    s = requests.Session()
    s.headers.update({
        "User-Agent": UA,
        "Accept": "text/xml,application/xml;q=0.9,*/*;q=0.8",
        "Accept-Language": AC_LANG,
        "Connection": "keep-alive",
        "Pragma": "no-cache",
        "Cache-Control": "no-cache",
        "Referer": "https://boardgamegeek.com/",
    })
    return s

def fetch_batch(session, ids):
    params = {"stats":"1","versions":VERSIONS,"id":",".join(str(i) for i in ids)}
    for host in HOSTS:
        url = f"https://{host}/xmlapi2/thing"
        for k in range(RETRY):
            try:
                r = session.get(url, params=params, timeout=45)
                if r.status_code == 200 and r.text.strip():
                    return parse_xml(r.text)
                if r.status_code in (401,403,429,503):
                    time.sleep(SLEEP * (1 + random.random()*JITTER) * (1.5**k))
                    continue
                time.sleep(2.0)
            except Exception:
                time.sleep(2.0)
    return None

def fetch_single(session, one):
    res = fetch_batch(session, [one])
    return res[0] if res else None

def main():
    if not IDS_FILE.exists():
        print("No data/bgg_ids.json; skip"); return
    ids = load_ids()
    sess = get_session()

    # 舊檔增量
    old = []
    if OUT_FILE.exists():
        try: old = json.loads(OUT_FILE.read_text(encoding="utf-8"))
        except: old = []
    cache = {int(x.get("bgg_id",0)): x for x in old if isinstance(x,dict)}

    ok = []
    for i in range(0, len(ids), BATCH):
        chunk = ids[i:i+BATCH]
        got = fetch_batch(sess, chunk)
        if got is None:
            for one in chunk:
                it = fetch_single(sess, one)
                if it: ok.append(it)
        else:
            ok.extend(got)
        time.sleep(SLEEP * (1 + random.random()*JITTER))

    merged = {int(x.get("bgg_id",0)): x for x in ok if isinstance(x,dict)}
    merged.update(cache)  # 新覆蓋舊
    final = list(merged.values())

    TMP_FILE.parent.mkdir(parents=True, exist_ok=True)
    TMP_FILE.write_text(json.dumps(final, ensure_ascii=False, indent=2), encoding="utf-8")

    if len(ok) >= MIN_SAVE or not OUT_FILE.exists():
        TMP_FILE.replace(OUT_FILE)
        print(f"Fetched {len(ok)} new / total {len(final)} → {OUT_FILE}")
    else:
        print(f"FETCH GUARD: only {len(ok)} (<{MIN_SAVE}) new; keep previous {OUT_FILE}")

if __name__ == "__main__":
    main()
PY

          # --- scripts/apply_taxonomy_and_price.py（沿用你原本） ---
          # 若你已有，這段可不覆蓋；此處略。

          # --- scripts/fetch_version_image.py / download_images.py（沿用你原本） ---
          # 略；保留現有檔案不動

          # --- scripts/build_json.py（門檻＋備份回填） ---
          cat <<'PY' > scripts/build_json.py
import json, datetime, hashlib, os, re
from pathlib import Path

INPUT  = Path("data/bgg_data.json")
OUTPUT = Path("data/games_full.json")
BACKUP = Path("data/games_full_backup.json")
MIN_BUILD = int(os.getenv("BUILD_MIN_ITEMS", "10"))

_CJK = re.compile(r"[\u4E00-\u9FFF\u3400-\u4DBF]")

def slugify(s: str) -> str:
    return (s or "").strip().lower().replace(" ", "_")

def make_id(r: dict) -> str:
    bid  = r.get("bgg_id")
    base = slugify(r.get("name_en_override") or r.get("name_en") or r.get("name_zh") or (f"bgg_{bid}" if bid else "game"))
    ovr = r.get("image_override")
    if ovr: return f"{base}-{hashlib.md5(str(ovr).encode('utf-8')).hexdigest()[:8]}"
    ver = r.get("image_version_id") or r.get("image_version_used")
    if ver: return f"{base}-v{str(ver).strip()}"
    if bid: return f"{base}-{bid}"
    return base

def has_zh(nz, ne)->bool:
    s = (nz or "") + " " + (ne or "")
    return bool(_CJK.search(s))

def main():
    if not INPUT.exists():
        print("No data/bgg_data.json; skip build_json."); return

    rows = json.loads(INPUT.read_text(encoding="utf-8"))
    # 安全閥：抓到太少 → 維持舊檔或備份
    if len(rows) < MIN_BUILD:
        if OUTPUT.exists():
            old_n = len(json.loads(OUTPUT.read_text(encoding="utf-8")))
            print(f"BUILD GUARD: input {len(rows)} (<{MIN_BUILD}); keep previous games_full.json ({old_n})"); return
        if BACKUP.exists():
            OUTPUT.write_text(BACKUP.read_text(encoding="utf-8"), encoding="utf-8")
            print(f"BUILD GUARD: input {len(rows)}; restored from backup."); return
        print(f"BUILD GUARD: input {len(rows)}; no previous file. continue (first run).")

    items=[]; today = datetime.date.today().isoformat()
    for r in rows:
        bid     = r.get("bgg_id")
        name_zh = r.get("name_zh")
        name_en = r.get("name_en_override") or r.get("name_en") or r.get("bgg_query")
        image   = r.get("image") or r.get("image_url") or r.get("thumb_url")
        if r.get("image_override"): image = r["image_override"]

        item = dict(r)
        item["id"] = make_id(r)
        item["name_zh"] = name_zh or ""
        item["name_en"] = name_en or ""
        item["image"]   = image or ""
        if bid and not item.get("bgg_url"):
            item["bgg_url"] = f"https://boardgamegeek.com/boardgame/{bid}"
        if not item.get("search_keywords"):
            kws=[]
            if name_zh: kws.append(f"{name_zh} BGG")
            if name_en: kws.append(f"{name_en} BGG")
            item["search_keywords"]=kws
        item["has_zh_name"] = has_zh(item["name_zh"], item["name_en"])
        item["updated_at"]=today
        items.append(item)

    def _sort_key(x):
        n = (x.get("name_zh") or x.get("name_en") or "").lower()
        zh_key = 0 if has_zh(x.get("name_zh"), x.get("name_en")) else 1
        return (zh_key, n)

    items.sort(key=_sort_key)
    OUTPUT.parent.mkdir(parents=True, exist_ok=True)
    OUTPUT.write_text(json.dumps(items, ensure_ascii=False, indent=2), encoding="utf-8")
    print(f"Built {len(items)} entries → {OUTPUT}")
if __name__ == "__main__":
    main()
PY

      # 這一步回答你「去哪邊 BASH？」——它就是一個獨立 step（runner 用 bash 執行）
      - name: Ensure backup exists
        run: |
          mkdir -p data
          if [ -f data/games_full.json ] && [ ! -f data/games_full_backup.json ]; then
            cp data/games_full.json data/games_full_backup.json
          fi

      # 這一步回答你「env 放哪裡？」——就放在 Run scripts 這個 step（與 run 同層）
      - name: Run scripts
        env:
          BGG_HOSTS: 'api.geekdo.com,boardgamegeek.com'
          BGG_BATCH: '6'
          BGG_SLEEP: '4.0'
          BGG_RETRY: '6'
          BGG_JITTER: '0.8'
          BGG_MIN_SAVE: '50'
          BGG_VERSIONS: '0'
          BUILD_MIN_ITEMS: '10'
        run: |
          python scripts/resolve_bgg.py
          python scripts/fetch_bgg.py
          python scripts/apply_taxonomy_and_price.py || true
          python scripts/make_mechanism_map.py      || true
          python scripts/fetch_version_image.py     || true
          python scripts/download_images.py         || true
          python scripts/build_json.py

      - name: Commit changes
        run: |
          git config --local user.name  "github-actions[bot]"
          git config --local user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git rm -f data/comments_cache.json 2>/dev/null || true
          git rm -f scripts/fetch_comments.py 2>/dev/null || true
          git add data/games_full.json data/games_full_backup.json data/bgg_data.json data/bgg_ids.json || true
          git add data/mechanism_map_zh.csv data/mechanism_map_candidates.csv || true
          git add assets/img/* || true
          git commit -m "Auto-update game data (guarded)" || echo "No changes to commit"
          git push || echo "No changes to push"
