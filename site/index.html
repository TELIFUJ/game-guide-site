<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <title>Board Game Guide</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <style>
    :root {
      --bg: #f5f5f7;
      --card-bg: #ffffff;
      --accent: #2563eb;
      --accent-soft: #dbeafe;
      --border: #e5e7eb;
      --text-main: #111827;
      --text-muted: #6b7280;
      --chip-bg: #f3f4f6;
      --danger: #b91c1c;
    }
    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg);
      color: var(--text-main);
    }

    header {
      background: #111827;
      color: #f9fafb;
      padding: 0.6rem 1.5rem;
    }
    .header-title {
      max-width: 1200px;
      margin: 0 auto;
      font-weight: 600;
      font-size: 1rem;
    }

    main {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0.8rem 1.5rem 2rem;
    }

    /* å·¥å…·åˆ— */
    .toolbar {
      background: #fff;
      border-radius: 1rem;
      border: 1px solid var(--border);
      padding: 0.75rem 0.9rem;
      margin-bottom: 0.75rem;
    }
    .toolbar-row1 {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
      align-items: center;
      margin-bottom: 0.4rem;
    }
    .search-box {
      flex: 2 1 220px;
      min-width: 200px;
      display: flex;
      align-items: center;
      gap: 0.4rem;
      border-radius: 999px;
      border: 1px solid var(--border);
      padding: 0.25rem 0.8rem;
      background: #f9fafb;
    }
    .search-box input {
      border: none;
      outline: none;
      background: transparent;
      width: 100%;
      font-size: 0.9rem;
    }
    .select {
      border-radius: 999px;
      border: 1px solid var(--border);
      padding: 0.32rem 0.8rem;
      font-size: 0.85rem;
      background: #fff;
    }
    .btn {
      border-radius: 999px;
      border: 1px solid var(--border);
      padding: 0.32rem 0.9rem;
      font-size: 0.85rem;
      background: #fff;
      cursor: pointer;
      white-space: nowrap;
    }
    .btn-primary {
      background: var(--accent);
      border-color: var(--accent);
      color: #fff;
    }
    .btn-outline {
      border-color: var(--accent);
      color: var(--accent);
      background: #fff;
    }

    .toolbar-row2 {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      font-size: 0.75rem;
      color: var(--text-muted);
      gap: 0.3rem;
    }
    .toolbar-badges {
      display: flex;
      flex-wrap: wrap;
      gap: 0.2rem;
    }
    .badge {
      border-radius: 999px;
      padding: 0.05rem 0.45rem;
      background: #fef3c7;
      color: #92400e;
    }

    /* å€å¡Šæ¨™é¡Œ */
    h2 {
      font-size: 0.98rem;
      margin: 0.8rem 0 0.4rem;
      display: flex;
      justify-content: space-between;
      align-items: baseline;
    }
    .section-note {
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    /* éš¨æ©Ÿé è¦½ */
    .random-preview {
      background: #fff;
      border-radius: 1rem;
      border: 1px solid var(--border);
      padding: 0.6rem 0.7rem 0.8rem;
    }
    .random-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill,minmax(220px,1fr));
      gap: 0.6rem;
    }

    /* å¡ç‰‡ */
    .cards-header-row {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      font-size: 0.8rem;
      color: var(--text-muted);
      margin: 0.6rem 0;
    }

    .cards-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill,minmax(240px,1fr));
      gap: 0.75rem;
    }

    .card {
      background: var(--card-bg);
      border-radius: 1rem;
      border: 1px solid var(--border);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      font-size: 0.78rem;
    }
    .card-img-wrapper {
      position: relative;
      padding-top: 66%; /* æ¥è¿‘ 3:2ï¼Œæ¯”è¼ƒåƒåŸæœ¬ BGG å°é¢æ¯”ä¾‹ */
      background: #e5e7eb;
      overflow: hidden;
    }
    .card-img {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;   /* ä¿æŒæ»¿ç‰ˆï¼Œé¿å…è®Šå½¢ */
    }
    .card-body {
      padding: 0.6rem 0.7rem 0.65rem;
      display: flex;
      flex-direction: column;
      gap: 0.28rem;
    }
    .card-title {
      font-size: 0.9rem;
      font-weight: 600;
      line-height: 1.2;
    }
    .card-subtitle {
      font-size: 0.7rem;
      color: var(--text-muted);
    }
    .meta-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.2rem 0.7rem;
      font-size: 0.7rem;
      color: var(--text-muted);
      margin-top: 0.1rem;
    }
    .meta-tag strong {
      font-weight: 600;
      color: var(--text-main);
    }

    .price-stock {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.76rem;
      margin-top: 0.1rem;
    }
    .price {
      color: var(--accent);
      font-weight: 600;
    }
    .stock {
      color: var(--text-muted);
    }
    .stock-zero {
      color: var(--danger);
      font-weight: 600;
    }

    .chips-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.2rem;
      margin-top: 0.25rem;
    }
    .chip {
      border-radius: 999px;
      padding: 0.1rem 0.45rem;
      background: var(--chip-bg);
      color: var(--text-muted);
      font-size: 0.66rem;
      border: 1px solid transparent;
      cursor: pointer;
      white-space: nowrap;
    }

    .card-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.35rem 0.7rem 0.55rem;
      border-top: 1px solid var(--border);
      font-size: 0.72rem;
    }
    .footer-buttons {
      display: flex;
      gap: 0.35rem;
    }
    .btn-ghost {
      border-radius: 999px;
      border: 1px solid var(--border);
      padding: 0.12rem 0.5rem;
      background: #fff;
      cursor: pointer;
    }
    .btn-link {
      border-radius: 999px;
      border: 1px solid var(--accent);
      padding: 0.12rem 0.5rem;
      background: #fff;
      color: var(--accent);
      text-decoration: none;
    }

    /* æ¨è–¦å€ */
    .recommend-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill,minmax(220px,1fr));
      gap: 0.6rem;
    }
    .recommend-note {
      font-size: 0.76rem;
      color: var(--text-muted);
      margin-bottom: 0.35rem;
    }

    /* åˆ†é  */
    .pagination {
      margin-top: 0.5rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.78rem;
      color: var(--text-muted);
    }
    .pagination-buttons {
      display: flex;
      gap: 0.3rem;
    }

    /* RWDï¼šå¹³æ¿èˆ‡æ‰‹æ©Ÿå„ªåŒ– */
    @media (max-width: 1024px) {
      .cards-grid {
        grid-template-columns: repeat(auto-fill,minmax(210px,1fr));
      }
      .random-grid {
        grid-template-columns: repeat(auto-fill,minmax(200px,1fr));
      }
    }
    @media (max-width: 768px) {
      .toolbar-row1 {
        flex-direction: column;
        align-items: stretch;
      }
      .search-box {
        width: 100%;
      }
      .cards-grid,
      .random-grid,
      .recommend-grid {
        grid-template-columns: repeat(2,minmax(0,1fr));
      }
      .card-img-wrapper {
        padding-top: 120%; /* æ‰‹æ©Ÿä¸Šæ”¹æˆè¼ƒæ¥è¿‘ 1:1ï¼Œæ¯”è¼ƒä¸æœƒå¤ªå¯¬ */
      }
    }
    @media (max-width: 480px) {
      .cards-grid,
      .random-grid,
      .recommend-grid {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <header>
    <div class="header-title">Board Game Guideï½œé€¢ç”²æ¡ŒéŠåº—ï½œç§Ÿå€Ÿèˆ‡äºŒæ‰‹å°ˆç”¨å°è¦½</div>
  </header>

  <main>
    <!-- å·¥å…·åˆ— -->
    <section class="toolbar">
      <div class="toolbar-row1">
        <div class="search-box">
          <span style="font-size:0.85rem;">ğŸ”</span>
          <input id="searchInput" type="text" placeholder="æœå°‹éŠæˆ²åç¨±ï¼ˆä¸­ï¼è‹±ï¼‰â€¦">
        </div>

        <select id="categorySelect" class="select">
          <option value="">å…¨éƒ¨åˆ†é¡</option>
        </select>

        <select id="mechanismSelect" class="select">
          <option value="">å…¨éƒ¨æ©Ÿåˆ¶</option>
        </select>

        <select id="sortSelect" class="select">
          <option value="name_zh">æŒ‰åç¨±ï¼ˆä¸­æ–‡ï¼‰</option>
          <option value="rating_bayes_desc">Bayes è©•åˆ†ï¼ˆé«˜â†’ä½ï¼‰</option>
          <option value="rating_avg_desc">å¹³å‡åˆ†æ•¸ï¼ˆé«˜â†’ä½ï¼‰</option>
          <option value="users_rated_desc">è©•åˆ†äººæ•¸ï¼ˆå¤šâ†’å°‘ï¼‰</option>
          <option value="weight_asc">é‡é‡ï¼ˆè¼•â†’é‡ï¼‰</option>
          <option value="weight_desc">é‡é‡ï¼ˆé‡â†’è¼•ï¼‰</option>
          <option value="price_asc">åƒ¹æ ¼ï¼ˆä½â†’é«˜ï¼‰</option>
          <option value="price_desc">åƒ¹æ ¼ï¼ˆé«˜â†’ä½ï¼‰</option>
        </select>

        <select id="pageSizeSelect" class="select">
          <option value="25">æ¯é  25 ç­†</option>
          <option value="50">æ¯é  50 ç­†</option>
          <option value="100">æ¯é  100 ç­†</option>
        </select>

        <button id="randomButton" class="btn btn-primary" type="button">éš¨æ©Ÿé è¦½</button>
        <button id="clearButton" class="btn btn-outline" type="button">æ¸…é™¤ç¯©é¸</button>
      </div>

      <div class="toolbar-row2">
        <div id="datasetStats"></div>
        <div class="toolbar-badges" id="activeFilters"></div>
      </div>
    </section>

    <!-- éš¨æ©Ÿé è¦½ -->
    <section>
      <h2>
        <span>éš¨æ©Ÿé è¦½</span>
        <span class="section-note">å¾ç›®å‰è³‡æ–™ä¸­æŒ‘é¸ 4 æ¬¾</span>
      </h2>
      <div class="random-preview">
        <div id="randomContainer" class="random-grid"></div>
      </div>
    </section>

    <!-- æ‰€æœ‰éŠæˆ² -->
    <section>
      <h2>
        <span>æ‰€æœ‰éŠæˆ²</span>
        <span class="section-note">å¡ç‰‡ä¸‹æ–¹ chips å¯é»é¸ç¯©é¸ï¼Œå³ä¸‹è§’å« BGG é€£çµ</span>
      </h2>

      <div class="cards-header-row">
        <div id="resultStats"></div>
        <div id="taxStats"></div>
      </div>

      <div id="cardsContainer" class="cards-grid"></div>

      <div class="pagination">
        <div id="pageInfo"></div>
        <div class="pagination-buttons">
          <button id="prevPageBtn" class="btn" type="button">ä¸Šä¸€é </button>
          <button id="nextPageBtn" class="btn" type="button">ä¸‹ä¸€é </button>
        </div>
      </div>
    </section>

    <!-- ä½ å¯èƒ½ä¹Ÿæœƒå–œæ­¡ -->
    <section>
      <h2>ä½ å¯èƒ½ä¹Ÿæœƒå–œæ­¡</h2>
      <div id="recommendNote" class="recommend-note"></div>
      <div id="recommendContainer" class="recommend-grid"></div>
    </section>
  </main>

  <script>
    // ======= ä¸­è‹±æ–‡å°ç…§ MAPï¼ˆç”± CSV è¼‰å…¥ï¼‰ =======
    const CATEGORY_ZH_MAP = {};
    const MECHANISM_ZH_MAP = {};

    function toZhCategory(name) {
      if (!name) return '';
      return CATEGORY_ZH_MAP[name] || name;
    }
    function toZhMechanism(name) {
      if (!name) return '';
      return MECHANISM_ZH_MAP[name] || name;
    }

    async function loadCsvMap(label, paths, targetMap) {
      let lastError = null;
      for (const p of paths) {
        try {
          const res = await fetch(p, { cache: 'no-store' });
          if (!res.ok) continue;
          const text = await res.text();
          parseCsvToMap(text, targetMap);
          console.log(`è¼‰å…¥ ${label} å°ç…§è¡¨ï¼š${Object.keys(targetMap).length} ç­†ï¼ˆ${p}ï¼‰`);
          return;
        } catch (e) {
          lastError = e;
        }
      }
      console.warn(`è¼‰å…¥ ${label} å°ç…§è¡¨å¤±æ•—`, lastError);
    }

    function parseCsvToMap(text, targetMap) {
      if (!text) return;
      const lines = text.split(/\r?\n/);
      if (lines.length <= 1) return;

      for (let i = 1; i < lines.length; i++) {
        let line = lines[i];
        if (!line) continue;
        line = line.trim();
        if (!line || line.startsWith('#')) continue;
        line = line.replace(/^\uFEFF/, ''); // å»æ‰ BOM

        const idx = line.lastIndexOf(',');
        if (idx <= 0) continue;
        const en = line.slice(0, idx).trim();
        const zh = line.slice(idx + 1).trim();
        if (!en || !zh) continue;
        targetMap[en] = zh;
      }
    }

    // ======= å…¨åŸŸè³‡æ–™èˆ‡ç‹€æ…‹ =======
    let allGames = [];
    let filteredGames = [];

    const state = {
      searchText: '',
      categoryKey: '',
      mechanismKey: '',
      sortKey: 'name_zh',
      pageSize: 25,
      currentPage: 0,
    };

    // DOM
    const searchInput      = document.getElementById('searchInput');
    const categorySelect   = document.getElementById('categorySelect');
    const mechanismSelect  = document.getElementById('mechanismSelect');
    const sortSelect       = document.getElementById('sortSelect');
    const pageSizeSelect   = document.getElementById('pageSizeSelect');
    const randomButton     = document.getElementById('randomButton');
    const clearButton      = document.getElementById('clearButton');

    const datasetStats     = document.getElementById('datasetStats');
    const activeFilters    = document.getElementById('activeFilters');
    const resultStats      = document.getElementById('resultStats');
    const taxStats         = document.getElementById('taxStats');

    const randomContainer  = document.getElementById('randomContainer');
    const cardsContainer   = document.getElementById('cardsContainer');
    const pageInfo         = document.getElementById('pageInfo');
    const prevPageBtn      = document.getElementById('prevPageBtn');
    const nextPageBtn      = document.getElementById('nextPageBtn');

    const recommendNote      = document.getElementById('recommendNote');
    const recommendContainer = document.getElementById('recommendContainer');

    // ======= è¼‰å…¥ JSON =======
    async function fetchWithFallback() {
      const paths = ['data/games.json', 'site/data/games.json'];
      let lastError = null;
      for (const p of paths) {
        try {
          const res = await fetch(p, { cache: 'no-store' });
          if (!res.ok) continue;
          const data = await res.json();
          return data;
        } catch (e) {
          lastError = e;
        }
      }
      console.error('è¼‰å…¥ games.json å¤±æ•—', lastError);
      alert('è®€å–éŠæˆ²è³‡æ–™å¤±æ•—ï¼Œè«‹æª¢æŸ¥ data/games.json / site/data/games.jsonã€‚');
      return [];
    }

    function filterByManualOverride(rawList) {
      const hasManual = rawList.some(r => r.manual_override !== undefined && r.manual_override !== null);
      if (!hasManual) return rawList;
      return rawList.filter(r => r.manual_override === 1 || r.manual_override === "1");
    }

    function normalizeGame(raw) {
      const categories = Array.isArray(raw.categories) ? raw.categories : [];
      const mechsField = raw.mechanisms || raw.mechanics;
      const mechanisms = Array.isArray(mechsField) ? mechsField : [];

      return {
        id: raw.id || String(raw.bgg_id || ''),
        nameZh: raw.name_zh || raw.name || '',
        nameEn: raw.name_en || raw.name || '',
        year: raw.year || null,
        minPlayers: raw.min_players ?? raw.minplayers ?? null,
        maxPlayers: raw.max_players ?? raw.maxplayers ?? null,
        minPlaytime: raw.min_playtime ?? raw.minplaytime ?? null,
        maxPlaytime: raw.max_playtime ?? raw.maxplaytime ?? null,
        ratingBayes: raw.rating_bayes ?? null,
        ratingAvg: raw.rating_avg ?? raw.rating ?? null,
        usersRated: raw.users_rated ?? raw.usersrated ?? null,
        weight: raw.weight_avg ?? raw.weight ?? null,
        mechanismCount: raw.mechanism_count ?? (Array.isArray(mechanisms) ? mechanisms.length : null),
        price: raw.used_price_twd ?? null,
        stock: raw.stock ?? null,
        image: raw.image || raw.thumbnail || '',
        bggUrl: raw.bgg_url || (raw.bgg_id ? `https://boardgamegeek.com/boardgame/${raw.bgg_id}` : null),
        categories,
        mechanisms,
      };
    }

    function buildTaxonomy(games) {
      const catMap = new Map();
      const mechMap = new Map();
      for (const g of games) {
        for (const c of g.categories) {
          if (!c) continue;
          catMap.set(c, (catMap.get(c) || 0) + 1);
        }
        for (const m of g.mechanisms) {
          if (!m) continue;
          mechMap.set(m, (mechMap.get(m) || 0) + 1);
        }
      }
      return { catMap, mechMap };
    }

    function initFilterSelects(catMap, mechMap) {
      categorySelect.innerHTML = '';
      mechanismSelect.innerHTML = '';

      const optAllC = document.createElement('option');
      optAllC.value = '';
      optAllC.textContent = 'å…¨éƒ¨åˆ†é¡';
      categorySelect.appendChild(optAllC);

      const sortedCats = Array.from(catMap.entries()).sort((a, b) => b[1] - a[1]);
      for (const [name, count] of sortedCats) {
        const opt = document.createElement('option');
        opt.value = name;
        opt.textContent = `${toZhCategory(name)} (${count})`;
        categorySelect.appendChild(opt);
      }

      const optAllM = document.createElement('option');
      optAllM.value = '';
      optAllM.textContent = 'å…¨éƒ¨æ©Ÿåˆ¶';
      mechanismSelect.appendChild(optAllM);

      const sortedMechs = Array.from(mechMap.entries()).sort((a, b) => b[1] - a[1]);
      for (const [name, count] of sortedMechs) {
        const opt = document.createElement('option');
        opt.value = name;
        opt.textContent = `${toZhMechanism(name)} (${count})`;
        mechanismSelect.appendChild(opt);
      }
    }

    // ======= ç¯©é¸èˆ‡æ’åº =======
    function applyFilters() {
      const text = state.searchText.trim().toLowerCase();
      const catKey = state.categoryKey;
      const mechKey = state.mechanismKey;

      filteredGames = allGames.filter(g => {
        if (text) {
          const t = `${g.nameZh || ''} ${g.nameEn || ''}`.toLowerCase();
          if (!t.includes(text)) return false;
        }
        if (catKey) {
          const s = new Set(g.categories);
          if (!s.has(catKey)) return false;
        }
        if (mechKey) {
          const s = new Set(g.mechanisms);
          if (!s.has(mechKey)) return false;
        }
        return true;
      });

      sortGames(filteredGames, state.sortKey);
      state.currentPage = 0;
      renderAll();
    }

    function sortGames(list, key) {
      list.sort((a, b) => {
        switch (key) {
          case 'rating_bayes_desc':
            return (b.ratingBayes ?? -999) - (a.ratingBayes ?? -999);
          case 'rating_avg_desc':
            return (b.ratingAvg ?? -999) - (a.ratingAvg ?? -999);
          case 'users_rated_desc':
            return (b.usersRated ?? -999) - (a.usersRated ?? -999);
          case 'weight_asc':
            return (a.weight ?? 999) - (b.weight ?? 999);
          case 'weight_desc':
            return (b.weight ?? -999) - (a.weight ?? -999);
          case 'price_asc':
            return (a.price ?? 9999999) - (b.price ?? 9999999);
          case 'price_desc':
            return (b.price ?? -9999999) - (a.price ?? -9999999);
          case 'name_zh':
          default: {
            const an = (a.nameZh || a.nameEn || '').toString();
            const bn = (b.nameZh || b.nameEn || '').toString();
            return an.localeCompare(bn, 'zh-Hant');
          }
        }
      });
    }

    // ======= æ¸²æŸ“ =======
    function renderStats(catMap, mechMap) {
      datasetStats.textContent =
        `è³‡æ–™ç¸½æ•¸ï¼š${allGames.length} ç­†ï¼ˆCSV æ¨™è¨˜å¾Œï¼‰ï½œåˆ†é¡ ${catMap.size} ç¨®ï½œæ©Ÿåˆ¶ ${mechMap.size} ç¨®`;

      resultStats.textContent =
        `ç›®å‰é¡¯ç¤ºï¼š${filteredGames.length} ç­†`;

      const parts = [];
      if (state.categoryKey) {
        parts.push(`åˆ†é¡ï¼š${toZhCategory(state.categoryKey)}`);
      }
      if (state.mechanismKey) {
        parts.push(`æ©Ÿåˆ¶ï¼š${toZhMechanism(state.mechanismKey)}`);
      }
      if (state.searchText.trim()) {
        parts.push(`æœå°‹ï¼šã€Œ${state.searchText.trim()}ã€`);
      }
      taxStats.textContent = parts.length ? parts.join(' ï½œ ') : '';

      activeFilters.innerHTML = '';
      if (state.categoryKey) {
        const b = document.createElement('span');
        b.className = 'badge';
        b.textContent = `åˆ†é¡ï¼š${toZhCategory(state.categoryKey)}`;
        activeFilters.appendChild(b);
      }
      if (state.mechanismKey) {
        const b = document.createElement('span');
        b.className = 'badge';
        b.textContent = `æ©Ÿåˆ¶ï¼š${toZhMechanism(state.mechanismKey)}`;
        activeFilters.appendChild(b);
      }
      if (state.searchText.trim()) {
        const b = document.createElement('span');
        b.className = 'badge';
        b.textContent = `æœå°‹ï¼šã€Œ${state.searchText.trim()}ã€`;
        activeFilters.appendChild(b);
      }
    }

    function renderRandomPreview() {
      randomContainer.innerHTML = '';
      const n = Math.min(4, allGames.length);
      const picks = pickRandom(allGames, n);
      for (const g of picks) {
        const card = createGameCard(g, {compact: true});
        randomContainer.appendChild(card);
      }
    }

    function renderCards() {
      cardsContainer.innerHTML = '';
      const pageSize = state.pageSize;
      const total = filteredGames.length;
      const pageCount = Math.max(1, Math.ceil(total / pageSize));
      const pageIndex = Math.min(state.currentPage, pageCount - 1);
      state.currentPage = pageIndex;

      const start = pageIndex * pageSize;
      const end = Math.min(start + pageSize, total);
      const slice = filteredGames.slice(start, end);

      for (const g of slice) {
        const card = createGameCard(g, {compact: false});
        cardsContainer.appendChild(card);
      }

      pageInfo.textContent =
        `ç¬¬ ${pageIndex + 1} / ${pageCount} é ï¼ˆé¡¯ç¤ºç¬¬ ${start + 1}â€“${end} ç­†ï¼‰`;

      prevPageBtn.disabled = pageIndex === 0;
      nextPageBtn.disabled = pageIndex >= pageCount - 1;

      if (slice.length > 0) {
        renderRecommendations(slice[0]);
      } else {
        recommendNote.textContent = 'ç›®å‰æ²’æœ‰ç¬¦åˆç¯©é¸æ¢ä»¶çš„éŠæˆ²ã€‚';
        recommendContainer.innerHTML = '';
      }
    }

    function renderRecommendations(baseGame) {
      recommendContainer.innerHTML = '';
      if (!baseGame) {
        recommendNote.textContent = 'å°šæœªé¸æ“‡åŸºæº–éŠæˆ²ã€‚';
        return;
      }

      recommendNote.textContent =
        `ä»¥ã€Œ${baseGame.nameZh || baseGame.nameEn}ã€ç‚ºåŸºæº–ï¼Œä¾æ©Ÿåˆ¶ï¼åˆ†é¡é‡ç–Šåº¦èˆ‡é‡é‡æ¥è¿‘åº¦æ¨è–¦ç´„ 5â€“8 æ¬¾ã€‚`;

      const sims = computeSimilarGames(baseGame, 8);
      for (const g of sims) {
        const card = createGameCard(g, {compact: true});
        recommendContainer.appendChild(card);
      }
    }

    function createGameCard(game, {compact}) {
      const card = document.createElement('article');
      card.className = 'card';

      const imgWrap = document.createElement('div');
      imgWrap.className = 'card-img-wrapper';
      const img = document.createElement('img');
      img.className = 'card-img';
      img.src = game.image || '';
      img.alt = game.nameZh || game.nameEn || '';
      imgWrap.appendChild(img);
      card.appendChild(imgWrap);

      const body = document.createElement('div');
      body.className = 'card-body';

      const title = document.createElement('div');
      title.className = 'card-title';
      title.textContent = game.nameZh || game.nameEn || '(æœªå‘½å)';
      body.appendChild(title);

      const subtitle = document.createElement('div');
      subtitle.className = 'card-subtitle';
      const parts = [];
      if (game.ratingBayes != null || game.ratingAvg != null) {
        parts.push(`Bayesï¼š${formatNumber(game.ratingBayes)}ï¼å‡åˆ†ï¼š${formatNumber(game.ratingAvg)}`);
      }
      if (game.usersRated != null) {
        parts.push(`è©•åˆ†äººæ•¸ï¼š${game.usersRated}`);
      }
      if (game.year) {
        parts.push(`å‡ºç‰ˆï¼š${game.year}`);
      }
      subtitle.textContent = parts.join(' ï½œ ');
      body.appendChild(subtitle);

      const metaRow = document.createElement('div');
      metaRow.className = 'meta-row';

      const pTag = document.createElement('span');
      pTag.className = 'meta-tag';
      pTag.innerHTML = `<strong>äººæ•¸ï¼š</strong>${formatRange(game.minPlayers, game.maxPlayers, 'äºº')}`;
      metaRow.appendChild(pTag);

      const tTag = document.createElement('span');
      tTag.className = 'meta-tag';
      tTag.innerHTML = `<strong>æ™‚é–“ï¼š</strong>${formatRange(game.minPlaytime, game.maxPlaytime, 'åˆ†')}`;
      metaRow.appendChild(tTag);

      const wTag = document.createElement('span');
      wTag.className = 'meta-tag';
      wTag.innerHTML = `<strong>é‡é‡ï¼š</strong>${formatNumber(game.weight)}`;
      metaRow.appendChild(wTag);

      const mTag = document.createElement('span');
      mTag.className = 'meta-tag';
      const mc = game.mechanismCount ?? (Array.isArray(game.mechanisms) ? game.mechanisms.length : null);
      mTag.innerHTML = `<strong>æ©Ÿåˆ¶æ•¸ï¼š</strong>${mc ?? '-'}`;
      metaRow.appendChild(mTag);

      body.appendChild(metaRow);

      const priceStock = document.createElement('div');
      priceStock.className = 'price-stock';

      const price = document.createElement('div');
      price.className = 'price';
      price.textContent = game.price != null ? `äºŒæ‰‹ï¼šNT$${game.price}` : 'åƒ¹æ ¼æœªè¨­å®š';
      priceStock.appendChild(price);

      const stock = document.createElement('div');
      stock.className = 'stock';
      if (game.stock == null) {
        stock.textContent = '';
      } else if (game.stock <= 0) {
        stock.textContent = 'åº«å­˜ï¼šå”®å®Œ';
        stock.classList.add('stock-zero');
      } else {
        stock.textContent = `åº«å­˜ï¼š${game.stock}`;
      }
      priceStock.appendChild(stock);

      body.appendChild(priceStock);

      const chipsRow = document.createElement('div');
      chipsRow.className = 'chips-row';

      game.categories.forEach(c => {
        const chip = document.createElement('button');
        chip.type = 'button';
        chip.className = 'chip';
        chip.textContent = toZhCategory(c);
        chip.title = c;
        chip.addEventListener('click', (ev) => {
          ev.stopPropagation();
          state.categoryKey = c;
          categorySelect.value = c;
          applyFilters();
        });
        chipsRow.appendChild(chip);
      });

      game.mechanisms.forEach(m => {
        const chip = document.createElement('button');
        chip.type = 'button';
        chip.className = 'chip';
        chip.textContent = toZhMechanism(m);
        chip.title = m;
        chip.addEventListener('click', (ev) => {
          ev.stopPropagation();
          state.mechanismKey = m;
          mechanismSelect.value = m;
          applyFilters();
        });
        chipsRow.appendChild(chip);
      });

      body.appendChild(chipsRow);
      card.appendChild(body);

      const footer = document.createElement('div');
      footer.className = 'card-footer';

      const left = document.createElement('div');
      left.textContent = '';
      footer.appendChild(left);

      const btns = document.createElement('div');
      btns.className = 'footer-buttons';

      const favBtn = document.createElement('button');
      favBtn.type = 'button';
      favBtn.className = 'btn-ghost';
      favBtn.textContent = 'â˜† æ”¶è—';
      btns.appendChild(favBtn);

      if (game.bggUrl) {
        const bggLink = document.createElement('a');
        bggLink.className = 'btn-link';
        bggLink.href = game.bggUrl;
        bggLink.target = '_blank';
        bggLink.rel = 'noopener noreferrer';
        bggLink.textContent = 'BGG';
        btns.appendChild(bggLink);
      }

      footer.appendChild(btns);
      card.appendChild(footer);

      card.addEventListener('click', () => {
        renderRecommendations(game);
      });

      if (compact) {
        card.style.fontSize = '0.74rem';
      }

      return card;
    }

    function pickRandom(list, n) {
      const copy = [...list];
      for (let i = copy.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [copy[i], copy[j]] = [copy[j], copy[i]];
      }
      return copy.slice(0, n);
    }

    function computeSimilarGames(baseGame, maxCount) {
      const baseCats = new Set(baseGame.categories);
      const baseMechs = new Set(baseGame.mechanisms);
      const baseWeight = baseGame.weight;

      const scored = [];
      for (const g of allGames) {
        if (g.id === baseGame.id) continue;

        let score = 0;
        g.categories.forEach(c => { if (baseCats.has(c)) score += 2; });
        g.mechanisms.forEach(m => { if (baseMechs.has(m)) score += 3; });

        if (baseWeight != null && g.weight != null) {
          score -= Math.abs(baseWeight - g.weight);
        }

        scored.push({ game: g, score });
      }

      scored.sort((a, b) => b.score - a.score);
      let picked = scored.filter(s => s.score > 0).slice(0, maxCount);

      if (picked.length < 5) {
        const used = new Set(picked.map(p => p.game.id));
        for (const s of scored) {
          if (picked.length >= maxCount) break;
          if (used.has(s.game.id)) continue;
          picked.push(s);
          used.add(s.game.id);
        }
      }

      return picked.slice(0, maxCount).map(p => p.game);
    }

    function formatNumber(x) {
      if (x == null || Number.isNaN(x)) return '-';
      const n = Number(x);
      if (!Number.isFinite(n)) return '-';
      return n.toFixed(2);
    }

    function formatRange(min, max, unit) {
      if (min == null && max == null) return '-';
      if (min != null && max != null && min !== max) {
        return `${min}-${max}${unit}`;
      }
      const v = min != null ? min : max;
      return `${v}${unit}`;
    }

    // ======= äº‹ä»¶ =======
    function setupEvents() {
      searchInput.addEventListener('input', (e) => {
        state.searchText = e.target.value || '';
        applyFilters();
      });

      categorySelect.addEventListener('change', (e) => {
        state.categoryKey = e.target.value || '';
        applyFilters();
      });

      mechanismSelect.addEventListener('change', (e) => {
        state.mechanismKey = e.target.value || '';
        applyFilters();
      });

      sortSelect.addEventListener('change', (e) => {
        state.sortKey = e.target.value;
        applyFilters();
      });

      pageSizeSelect.addEventListener('change', (e) => {
        const v = parseInt(e.target.value, 10);
        state.pageSize = Number.isNaN(v) ? 25 : v;
        state.currentPage = 0;
        renderCards();
      });

      clearButton.addEventListener('click', () => {
        state.searchText = '';
        state.categoryKey = '';
        state.mechanismKey = '';
        state.sortKey = 'name_zh';
        state.pageSize = 25;
        state.currentPage = 0;

        searchInput.value = '';
        categorySelect.value = '';
        mechanismSelect.value = '';
        sortSelect.value = 'name_zh';
        pageSizeSelect.value = '25';

        applyFilters();
      });

      randomButton.addEventListener('click', () => {
        renderRandomPreview();
      });

      prevPageBtn.addEventListener('click', () => {
        if (state.currentPage > 0) {
          state.currentPage -= 1;
          renderCards();
        }
      });

      nextPageBtn.addEventListener('click', () => {
        const total = filteredGames.length;
        const pageCount = Math.max(1, Math.ceil(total / state.pageSize));
        if (state.currentPage < pageCount - 1) {
          state.currentPage += 1;
          renderCards();
        }
      });
    }

    function renderAll() {
      const { catMap, mechMap } = buildTaxonomy(allGames);
      renderStats(catMap, mechMap);
      renderRandomPreview();
      renderCards();
    }

    // ======= åˆå§‹åŒ– =======
    (async function init() {
      // å…ˆè¼‰å…¥åˆ†é¡ï¼æ©Ÿåˆ¶å°ç…§è¡¨
      await Promise.all([
        loadCsvMap('category', ['../data/category_map_zh.csv', 'data/category_map_zh.csv'], CATEGORY_ZH_MAP),
        loadCsvMap('mechanism', ['../data/mechanism_map_zh.csv', 'data/mechanism_map_zh.csv'], MECHANISM_ZH_MAP),
      ]);

      const raw = await fetchWithFallback();
      const list = Array.isArray(raw) ? raw : [];
      const used = filterByManualOverride(list);
      allGames = used.map(normalizeGame);

      const { catMap, mechMap } = buildTaxonomy(allGames);
      initFilterSelects(catMap, mechMap);
      setupEvents();

      sortGames(allGames, state.sortKey);
      filteredGames = [...allGames];
      renderAll();
    })();
  </script>
</body>
</html>
