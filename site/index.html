<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <title>Board Game Guide</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <style>
    :root {
      --bg: #f5f5f7;
      --card-bg: #ffffff;
      --accent: #2563eb;
      --accent-soft: #dbeafe;
      --border: #e5e7eb;
      --text-main: #111827;
      --text-muted: #6b7280;
      --chip-bg: #f3f4f6;
      --danger: #b91c1c;
      --control-height: 34px;
    }
    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg);
      color: var(--text-main);
    }

    header {
      background: #111827;
      color: #f9fafb;
      padding: 0.6rem 1.5rem;
    }
    .header-title {
      max-width: 1400px;
      margin: 0 auto;
      font-weight: 600;
      font-size: 1rem;
    }

    main {
      max-width: 1400px;
      margin: 0 auto;
      padding: 0.8rem 1.2rem 2rem;
    }

    /* å·¥å…·åˆ— */
    .toolbar {
      background: #fff;
      border-radius: 1rem;
      border: 1px solid var(--border);
      padding: 0.75rem 0.9rem;
      margin-bottom: 0.75rem;
    }
    .toolbar-row1 {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
      align-items: center;
      margin-bottom: 0.4rem;
    }

    .search-box {
      flex: 2 1 220px;
      min-width: 200px;
      display: flex;
      align-items: center;
      gap: 0.4rem;
      border-radius: 999px;
      border: 1px solid var(--border);
      padding: 0 0.8rem;
      background: #f9fafb;
      height: var(--control-height);
    }
    .search-box input {
      border: none;
      outline: none;
      background: transparent;
      width: 100%;
      font-size: 0.9rem;
    }

    .select {
      border-radius: 999px;
      border: 1px solid var(--border);
      padding: 0 0.8rem;
      font-size: 0.85rem;
      background: #fff;
      height: var(--control-height);
    }
    .btn {
      border-radius: 999px;
      border: 1px solid var(--border);
      padding: 0 0.32rem;
      font-size: 0.85rem;
      background: #fff;
      cursor: pointer;
      white-space: nowrap;
      height: var(--control-height);
      display: flex;
      align-items: center;
    }
    .btn-primary {
      background: var(--accent);
      border-color: var(--accent);
      color: #fff;
    }
    .btn-outline {
      border-color: var(--accent);
      color: var(--accent);
      background: #fff;
    }
    .btn-toggle-active {
      background: var(--accent-soft);
      border-color: var(--accent);
      color: var(--accent);
    }

    .toolbar-row2 {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      font-size: 0.75rem;
      color: var(--text-muted);
      gap: 0.3rem;
    }
    .toolbar-badges {
      display: flex;
      flex-wrap: wrap;
      gap: 0.2rem;
    }
    .badge {
      border-radius: 999px;
      padding: 0.05rem 0.45rem;
      background: #fef3c7;
      color: #92400e;
    }

    h2 {
      font-size: 0.98rem;
      margin: 0.8rem 0 0.4rem;
      display: flex;
      justify-content: space-between;
      align-items: baseline;
    }
    .section-note {
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    #randomSection.collapsed {
      display: none;
    }
    .random-preview {
      background: #fff;
      border-radius: 1rem;
      border: 1px solid var(--border);
      padding: 0.6rem 0.7rem 0.8rem;
    }
    .random-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill,minmax(220px,1fr));
      gap: 0.6rem;
    }

    .cards-header-row {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      font-size: 0.8rem;
      color: var(--text-muted);
      margin: 0.6rem 0;
    }

    .cards-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill,minmax(220px,1fr));
      gap: 0.6rem;
    }

    .card {
      background: var(--card-bg);
      border-radius: 0.9rem;
      border: 1px solid var(--border);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      font-size: 0.78rem;
      cursor: pointer;
    }

    .card-focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 2px var(--accent-soft);
    }

    .card-img-wrapper {
      background: #f3f4f6;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 3px;
      height: 140px;
      overflow: hidden;
    }
    .card-img {
      max-width: 100%;
      max-height: 100%;
      width: auto;
      height: auto;
      object-fit: contain;
    }

    .card-body {
      padding: 0.55rem 0.7rem 0.6rem;
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }
    .card-title {
      font-size: 0.9rem;
      font-weight: 600;
      line-height: 1.2;
    }
    .card-subtitle {
      font-size: 0.7rem;
      color: var(--text-muted);
    }
    .meta-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.2rem 0.7rem;
      font-size: 0.7rem;
      color: var(--text-muted);
      margin-top: 0.05rem;
    }
    .meta-tag strong {
      font-weight: 600;
      color: var(--text-main);
    }

    .chips-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.2rem;
      margin-top: 0.25rem;
    }
    .chip {
      border-radius: 999px;
      padding: 0.1rem 0.45rem;
      background: var(--chip-bg);
      color: var(--text-muted);
      font-size: 0.66rem;
      border: 1px solid transparent;
      cursor: pointer;
      white-space: nowrap;
    }

    .price-stock {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.76rem;
      margin-top: 0.25rem;
    }
    .price {
      color: var(--accent);
      font-weight: 600;
    }
    .stock {
      color: var(--text-muted);
    }
    .stock-zero {
      color: var(--danger);
      font-weight: 600;
    }

    .card-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.35rem 0.7rem 0.55rem;
      border-top: 1px solid var(--border);
      font-size: 0.72rem;
      cursor: default;
    }
    .footer-buttons {
      display: flex;
      gap: 0.35rem;
    }
    .btn-ghost {
      border-radius: 999px;
      border: 1px solid var(--border);
      padding: 0.12rem 0.5rem;
      background: #fff;
      cursor: pointer;
    }
    .btn-ghost.is-fav {
      border-color: #f59e0b;
      color: #b45309;
      background: #fffbeb;
    }
    .btn-link {
      border-radius: 999px;
      border: 1px solid var(--accent);
      padding: 0.12rem 0.5rem;
      background: #fff;
      color: var(--accent);
      text-decoration: none;
      cursor: pointer;
    }

    .recommend-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill,minmax(220px,1fr));
      gap: 0.6rem;
    }
    .recommend-note {
      font-size: 0.76rem;
      color: var(--text-muted);
      margin: 0 0 0.35rem 0;
    }

    .pagination {
      margin-top: 0.5rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.78rem;
      color: var(--text-muted);
    }
    .pagination-buttons {
      display: flex;
      gap: 0.3rem;
    }

    .modal {
      position: fixed;
      inset: 0;
      display: none;
      align-items: flex-start;
      justify-content: center;
      padding: 3rem 1rem;
      background: rgba(0,0,0,0.45);
      z-index: 50;
    }
    .modal.show {
      display: flex;
    }
    .modal-dialog {
      background: #ffffff;
      max-width: 960px;
      width: 100%;
      max-height: calc(100vh - 4rem);
      overflow-y: auto;
      border-radius: 1rem;
      box-shadow: 0 10px 30px rgba(15,23,42,0.4);
      padding: 1rem 1.25rem 1.25rem;
      position: relative;
    }
    .modal-close {
      position: absolute;
      top: 0.5rem;
      right: 0.6rem;
      border: none;
      background: transparent;
      font-size: 1.2rem;
      cursor: pointer;
      color: var(--text-muted);
    }
    .modal-title {
      font-size: 1rem;
      font-weight: 600;
      margin: 0 2rem 0.4rem 0;
    }
    .modal-subtitle {
      font-size: 0.8rem;
      color: var(--text-muted);
      margin: 0 0 0.6rem 0;
    }
    .modal-section-title {
      font-size: 0.9rem;
      font-weight: 600;
      margin: 0.8rem 0 0.3rem;
    }

    @media (max-width: 1024px) {
      .cards-grid,
      .random-grid,
      .recommend-grid {
        grid-template-columns: repeat(auto-fill,minmax(210px,1fr));
      }
      .card-img-wrapper {
        height: 130px;
      }
    }
    @media (max-width: 768px) {
      .toolbar-row1 {
        flex-direction: column;
        align-items: stretch;
      }
      .search-box {
        width: 100%;
      }
      .cards-grid,
      .random-grid,
      .recommend-grid {
        grid-template-columns: repeat(2,minmax(0,1fr));
      }
      .card-img-wrapper {
        height: 125px;
      }
      .modal {
        padding: 1.5rem 0.5rem;
      }
      .modal-dialog {
        max-height: 100vh;
        border-radius: 0.75rem;
        padding: 0.9rem 0.9rem 1rem;
      }
    }
    @media (max-width: 480px) {
      .cards-grid,
      .random-grid,
      .recommend-grid {
        grid-template-columns: 1fr;
      }
      .card-img-wrapper {
        height: 120px;
      }
    }
  </style>
</head>
<body>
  <header>
    <div class="header-title">Board Game Guideï½œé€¢ç”²æ¡ŒéŠåº—ï½œç§Ÿå€Ÿèˆ‡äºŒæ‰‹å°ˆç”¨å°è¦½</div>
  </header>

  <main>
    <!-- å·¥å…·åˆ— -->
    <section class="toolbar">
      <div class="toolbar-row1">
        <div class="search-box">
          <span style="font-size:0.85rem;">ğŸ”</span>
          <input id="searchInput" type="text" placeholder="æœå°‹éŠæˆ²åç¨±ï¼ˆä¸­ï¼è‹±ï¼‰â€¦">
        </div>

        <select id="categorySelect" class="select">
          <option value="">å…¨éƒ¨åˆ†é¡</option>
        </select>

        <select id="mechanismSelect" class="select">
          <option value="">å…¨éƒ¨æ©Ÿåˆ¶</option>
        </select>

        <select id="sortSelect" class="select">
          <option value="name_zh">æŒ‰åç¨±ï¼ˆä¸­æ–‡ï¼‰</option>
          <option value="rating_bayes_desc">Bayes è©•åˆ†ï¼ˆé«˜â†’ä½ï¼‰</option>
          <option value="rating_avg_desc">å¹³å‡åˆ†æ•¸ï¼ˆé«˜â†’ä½ï¼‰</option>
          <option value="users_rated_desc">è©•åˆ†äººæ•¸ï¼ˆå¤šâ†’å°‘ï¼‰</option>
          <option value="weight_asc">é‡é‡ï¼ˆè¼•â†’é‡ï¼‰</option>
          <option value="weight_desc">é‡é‡ï¼ˆé‡â†’è¼•ï¼‰</option>
          <option value="price_asc">åƒ¹æ ¼ï¼ˆä½â†’é«˜ï¼‰</option>
          <option value="price_desc">åƒ¹æ ¼ï¼ˆé«˜â†’ä½ï¼‰</option>
        </select>

        <select id="pageSizeSelect" class="select">
          <option value="25">æ¯é  25 ç­†</option>
          <option value="50">æ¯é  50 ç­†</option>
          <option value="100">æ¯é  100 ç­†</option>
        </select>

        <button id="randomButton" class="btn btn-primary" type="button">éš¨æ©Ÿé è¦½</button>
        <button id="clearButton" class="btn btn-outline" type="button">æ¸…é™¤ç¯©é¸</button>
      </div>

      <div class="toolbar-row2">
        <div id="datasetStats"></div>
        <div style="display:flex;gap:0.3rem;align-items:center;flex-wrap:wrap;">
          <div class="toolbar-badges" id="activeFilters"></div>
          <button id="favFilterBtn" class="btn" type="button">åªçœ‹æ”¶è—</button>
          <button id="downloadFavBtn" class="btn" type="button">ä¸‹è¼‰æ”¶è—æ¸…å–®ï¼ˆCSVï¼‰</button>
        </div>
      </div>
    </section>

    <!-- éš¨æ©Ÿé è¦½ -->
    <section id="randomSection">
      <h2>
        <span>éš¨æ©Ÿé è¦½</span>
        <span class="section-note">å¾ç›®å‰è³‡æ–™ä¸­æŒ‘é¸ 4 æ¬¾</span>
      </h2>
      <div class="random-preview">
        <div id="randomContainer" class="random-grid"></div>
      </div>
    </section>

    <!-- æ‰€æœ‰éŠæˆ² -->
    <section>
      <h2>
        <span>æ‰€æœ‰éŠæˆ²</span>
        <span class="section-note">å¡ç‰‡ä¸‹æ–¹ chips å¯é»é¸ç¯©é¸ï¼Œå³ä¸‹è§’å« BGG é€£çµ</span>
      </h2>

      <div class="cards-header-row">
        <div id="resultStats"></div>
        <div id="taxStats"></div>
      </div>

      <div id="cardsContainer" class="cards-grid"></div>

      <div class="pagination">
        <div id="pageInfo"></div>
        <div class="pagination-buttons">
          <button id="prevPageBtn" class="btn" type="button">ä¸Šä¸€é </button>
          <button id="nextPageBtn" class="btn" type="button">ä¸‹ä¸€é </button>
        </div>
      </div>
    </section>
  </main>

  <!-- è©³ç´°ï¼‹æ¨è–¦ Modal -->
  <div id="cardModal" class="modal">
    <div class="modal-dialog">
      <button id="cardModalClose" class="modal-close" type="button">âœ•</button>
      <div id="cardModalBody"></div>
    </div>
  </div>

  <script>
    // ===== ä¸­æ–‡å°ç…§è¡¨ï¼ˆåˆ†é¡ï¼æ©Ÿåˆ¶ï¼‰ =====
    const CATEGORY_ZH_MAP = {};
    const MECHANISM_ZH_MAP = {};

    function toZhCategory(name) {
      if (!name) return '';
      return CATEGORY_ZH_MAP[name] || name;
    }
    function toZhMechanism(name) {
      if (!name) return '';
      return MECHANISM_ZH_MAP[name] || name;
    }

    function stripQuotes(s) {
      if (s == null) return s;
      let t = String(s).trim();
      if (!t) return t;
      if ((t.startsWith('"') && t.endsWith('"')) ||
          (t.startsWith("'") && t.endsWith("'"))) {
        t = t.slice(1, -1).trim();
      }
      return t;
    }

    async function loadCsvMap(label, paths, targetMap) {
      let lastError = null;
      for (const p of paths) {
        try {
          const res = await fetch(p, { cache: 'no-store' });
          if (!res.ok) continue;
          const text = await res.text();
          parseCsvToMap(text, targetMap);
          console.log(`[è¼‰å…¥] ${label} å°ç…§è¡¨ï¼š${Object.keys(targetMap).length} ç­†ï¼ˆ${p}ï¼‰`);
          return;
        } catch (e) {
          lastError = e;
        }
      }
      console.warn(`[è­¦å‘Š] è¼‰å…¥ ${label} å°ç…§è¡¨å¤±æ•—`, lastError);
    }

    function parseCsvToMap(text, targetMap) {
      if (!text) return;
      const lines = text.split(/\r?\n/);
      if (lines.length <= 1) return;

      for (let i = 1; i < lines.length; i++) {
        let line = lines[i];
        if (!line) continue;
        line = line.trim();
        if (!line || line.startsWith('#')) continue;
        line = line.replace(/^\uFEFF/, '');

        const idx = line.lastIndexOf(',');
        if (idx <= 0) continue;
        let en = line.slice(0, idx).trim();
        let zh = line.slice(idx + 1).trim();

        en = stripQuotes(en);
        zh = stripQuotes(zh);

        if (!en || !zh) continue;
        targetMap[en] = zh;
      }
    }

    // ===== è®€å–éŠæˆ²è³‡æ–™èˆ‡æ”¶è— =====
    let allGames = [];
    let filteredGames = [];
    let favoriteIds = new Set();
    let randomVisible = true;
    let focusGame = null;

    const FAVORITE_KEY = 'bggFavorites';

    const searchInput      = document.getElementById('searchInput');
    const categorySelect   = document.getElementById('categorySelect');
    const mechanismSelect  = document.getElementById('mechanismSelect');
    const sortSelect       = document.getElementById('sortSelect');
    const pageSizeSelect   = document.getElementById('pageSizeSelect');
    const randomButton     = document.getElementById('randomButton');
    const clearButton      = document.getElementById('clearButton');
    const downloadFavBtn   = document.getElementById('downloadFavBtn');
    const favFilterBtn     = document.getElementById('favFilterBtn');

    const datasetStats     = document.getElementById('datasetStats');
    const activeFilters    = document.getElementById('activeFilters');
    const resultStats      = document.getElementById('resultStats');
    const taxStats         = document.getElementById('taxStats');

    const randomSection    = document.getElementById('randomSection');
    const randomContainer  = document.getElementById('randomContainer');
    const cardsContainer   = document.getElementById('cardsContainer');
    const pageInfo         = document.getElementById('pageInfo');
    const prevPageBtn      = document.getElementById('prevPageBtn');
    const nextPageBtn      = document.getElementById('nextPageBtn');

    const cardModal        = document.getElementById('cardModal');
    const cardModalBody    = document.getElementById('cardModalBody');
    const cardModalClose   = document.getElementById('cardModalClose');

    const state = {
      searchText: '',
      categoryKey: '',
      mechanismKey: '',
      sortKey: 'name_zh',
      pageSize: 25,
      currentPage: 0,
      onlyFavorites: false,
    };

    function loadFavorites() {
      try {
        const raw = localStorage.getItem(FAVORITE_KEY);
        if (!raw) return;
        const arr = JSON.parse(raw);
        if (Array.isArray(arr)) {
          favoriteIds = new Set(arr);
        }
      } catch (e) {
        console.warn('è®€å–æ”¶è—æ¸…å–®å¤±æ•—', e);
      }
    }

    function saveFavorites() {
      try {
        localStorage.setItem(FAVORITE_KEY, JSON.stringify([...favoriteIds]));
      } catch (e) {
        console.warn('å„²å­˜æ”¶è—æ¸…å–®å¤±æ•—', e);
      }
    }

    function csvEscape(value) {
      const s = String(value ?? '');
      if (/[",\r\n]/.test(s)) {
        return '"' + s.replace(/"/g, '""') + '"';
      }
      return s;
    }

    function downloadFavoritesAsCSV() {
      const favGames = allGames.filter(g => favoriteIds.has(g.id));
      if (favGames.length === 0) {
        alert('ç›®å‰æ²’æœ‰æ”¶è—çš„éŠæˆ²ã€‚');
        return;
      }

      const header = [
        'id',
        'name_zh',
        'name_en',
        'price_twd',
        'stock',
        'categories',
        'mechanisms',
        'bgg_url'
      ];

      const rows = favGames.map(g => [
        g.id,
        g.nameZh || '',
        g.nameEn || '',
        g.price != null ? g.price : '',
        g.stock != null ? g.stock : '',
        (g.categories || []).join('; '),
        (g.mechanisms || []).join('; '),
        g.bggUrl || ''
      ]);

      const csv = [header, ...rows]
        .map(cols => cols.map(csvEscape).join(','))
        .join('\r\n');

      const blob = new Blob(['\uFEFF' + csv], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'boardgame_favorites.csv';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    async function fetchWithFallback() {
      const paths = ['data/games.json', 'site/data/games.json'];
      let lastError = null;
      for (const p of paths) {
        try {
          const res = await fetch(p, { cache: 'no-store' });
          if (!res.ok) continue;
          const data = await res.json();
          console.log(`[è¼‰å…¥] games.jsonï¼š${p}ï¼ˆç­†æ•¸ï¼š${Array.isArray(data) ? data.length : 'N/A'}ï¼‰`);
          return data;
        } catch (e) {
          lastError = e;
        }
      }
      console.error('è¼‰å…¥ games.json å¤±æ•—', lastError);
      alert('è®€å–éŠæˆ²è³‡æ–™å¤±æ•—ï¼Œè«‹æª¢æŸ¥ data/games.json / site/data/games.jsonã€‚');
      return [];
    }

    function filterByManualOverride(rawList) {
      const hasManual = rawList.some(r => r.manual_override !== undefined && r.manual_override !== null);
      if (!hasManual) return rawList;
      return rawList.filter(r => r.manual_override === 1 || r.manual_override === '1');
    }

    // ===== åœ–ç‰‡è·¯å¾‘è½‰æ›ï¼ˆå·²ç°¡åŒ–ï¼Œä¸å†åŠ  /site/ï¼‰=====
    function resolveImageUrl(url) {
      if (!url) return '';
      let u = String(url).trim();
      if (!u) return '';
      // çµ•å°ç¶²å€ï¼šç›´æ¥ç”¨
      if (/^https?:\/\//i.test(u) || u.startsWith('//')) {
        return u;
      }
      // å»æ‰é–‹é ­çš„ ./ æˆ– /
      if (u.startsWith('./')) {
        u = u.slice(2);
      }
      while (u.startsWith('/')) {
        u = u.slice(1);
      }
      // ä¿ç•™ç›¸å°è·¯å¾‘ï¼Œä¾‹å¦‚ assets/img/xxx.jpg
      return u;
    }

    // ===== è³‡æ–™æ¨™æº–åŒ– =====
    function normalizeGame(raw) {
      const categoriesRaw = Array.isArray(raw.categories) ? raw.categories : [];
      const mechsField = raw.mechanisms || raw.mechanics;
      const mechanismsRaw = Array.isArray(mechsField) ? mechsField : [];

      const categories = categoriesRaw
        .map(c => stripQuotes(String(c || '').trim()))
        .filter(Boolean);
      const mechanisms = mechanismsRaw
        .map(m => stripQuotes(String(m || '').trim()))
        .filter(Boolean);

      const id = raw.id || String(raw.bgg_id || '');

      let image = raw.image || raw.thumbnail || '';
      image = resolveImageUrl(image);

      let usedPrice = raw.used_price_twd;
      if (typeof usedPrice === 'string' && usedPrice.trim() !== '') {
        const n = Number(usedPrice);
        usedPrice = Number.isFinite(n) ? n : null;
      }

      let stock = raw.stock;
      if (typeof stock === 'string' && stock.trim() !== '') {
        const n = Number(stock);
        stock = Number.isFinite(n) ? n : null;
      }

      const ratingBayes = raw.rating_bayes ?? null;
      const ratingAvg = raw.rating_avg ?? raw.rating ?? null;
      const usersRated = raw.users_rated ?? raw.usersrated ?? null;

      const weight = raw.weight_avg ?? raw.weight ?? null;
      const mechanismCount = raw.mechanism_count ??
        (Array.isArray(mechanisms) ? mechanisms.length : null);

      const nameZh = raw.name_zh || raw.nameZh || '';
      const nameEn = raw.name_en || raw.nameEn || raw.name || '';

      const bggUrl = raw.bgg_url ||
        (raw.bgg_id ? `https://boardgamegeek.com/boardgame/${raw.bgg_id}` : null);

      return {
        id,
        nameZh,
        nameEn,
        year: raw.year || null,
        minPlayers: raw.min_players ?? raw.minplayers ?? null,
        maxPlayers: raw.max_players ?? raw.maxplayers ?? null,
        minPlaytime: raw.min_playtime ?? raw.minplaytime ?? null,
        maxPlaytime: raw.max_playtime ?? raw.maxplaytime ?? null,
        ratingBayes,
        ratingAvg,
        usersRated,
        weight,
        mechanismCount,
        price: usedPrice ?? null,
        stock,
        image,
        bggUrl,
        categories,
        mechanisms
      };
    }

    function buildTaxonomy(games) {
      const catMap = new Map();
      const mechMap = new Map();
      for (const g of games) {
        for (const c of g.categories) {
          if (!c) continue;
          catMap.set(c, (catMap.get(c) || 0) + 1);
        }
        for (const m of g.mechanisms) {
          if (!m) continue;
          mechMap.set(m, (mechMap.get(m) || 0) + 1);
        }
      }
      return { catMap, mechMap };
    }

    function initFilterSelects(catMap, mechMap) {
      categorySelect.innerHTML = '';
      mechanismSelect.innerHTML = '';

      const optAllC = document.createElement('option');
      optAllC.value = '';
      optAllC.textContent = 'å…¨éƒ¨åˆ†é¡';
      categorySelect.appendChild(optAllC);

      const sortedCats = Array.from(catMap.entries()).sort((a, b) => b[1] - a[1]);
      for (const [name, count] of sortedCats) {
        const opt = document.createElement('option');
        opt.value = name;
        opt.textContent = `${toZhCategory(name)} (${count})`;
        categorySelect.appendChild(opt);
      }

      const optAllM = document.createElement('option');
      optAllM.value = '';
      optAllM.textContent = 'å…¨éƒ¨æ©Ÿåˆ¶';
      mechanismSelect.appendChild(optAllM);

      const sortedMechs = Array.from(mechMap.entries()).sort((a, b) => b[1] - a[1]);
      for (const [name, count] of sortedMechs) {
        const opt = document.createElement('option');
        opt.value = name;
        opt.textContent = `${toZhMechanism(name)} (${count})`;
        mechanismSelect.appendChild(opt);
      }
    }

    // ===== ç¯©é¸èˆ‡æ’åº =====
    function applyFilters() {
      const text = state.searchText.trim().toLowerCase();
      const catKey = state.categoryKey;
      const mechKey = state.mechanismKey;

      filteredGames = allGames.filter(g => {
        if (text) {
          const t = `${g.nameZh || ''} ${g.nameEn || ''}`.toLowerCase();
          if (!t.includes(text)) return false;
        }
        if (catKey) {
          const s = new Set(g.categories);
          if (!s.has(catKey)) return false;
        }
        if (mechKey) {
          const s = new Set(g.mechanisms);
          if (!s.has(mechKey)) return false;
        }
        if (state.onlyFavorites && !favoriteIds.has(g.id)) {
          return false;
        }
        return true;
      });

      sortGames(filteredGames, state.sortKey);
      state.currentPage = 0;
      renderAll();
    }

    function sortGames(list, key) {
      list.sort((a, b) => {
        switch (key) {
          case 'rating_bayes_desc':
            return (b.ratingBayes ?? -999) - (a.ratingBayes ?? -999);
          case 'rating_avg_desc':
            return (b.ratingAvg ?? -999) - (a.ratingAvg ?? -999);
          case 'users_rated_desc':
            return (b.usersRated ?? -999) - (a.usersRated ?? -999);
          case 'weight_asc':
            return (a.weight ?? 999) - (b.weight ?? 999);
          case 'weight_desc':
            return (b.weight ?? -999) - (a.weight ?? -999);
          case 'price_asc':
            return (a.price ?? 9999999) - (b.price ?? 9999999);
          case 'price_desc':
            return (b.price ?? -9999999) - (a.price ?? -9999999);
          case 'name_zh':
          default: {
            const an = (a.nameZh || a.nameEn || '').toString();
            const bn = (b.nameZh || b.nameEn || '').toString();
            return an.localeCompare(bn, 'zh-Hant');
          }
        }
      });
    }

    // ===== çµ±è¨ˆèˆ‡ UI =====
    function renderStats(catMap, mechMap) {
      datasetStats.textContent =
        `è³‡æ–™ç¸½æ•¸ï¼š${allGames.length} ç­†ï¼ˆCSV æ¨™è¨˜å¾Œï¼‰ï½œåˆ†é¡ ${catMap.size} ç¨®ï½œæ©Ÿåˆ¶ ${mechMap.size} ç¨®`;

      resultStats.textContent =
        `ç›®å‰é¡¯ç¤ºï¼š${filteredGames.length} ç­†`;

      const parts = [];
      if (state.categoryKey) {
        parts.push(`åˆ†é¡ï¼š${toZhCategory(state.categoryKey)}`);
      }
      if (state.mechanismKey) {
        parts.push(`æ©Ÿåˆ¶ï¼š${toZhMechanism(state.mechanismKey)}`);
      }
      if (state.searchText.trim()) {
        parts.push(`æœå°‹ï¼šã€Œ${state.searchText.trim()}ã€`);
      }
      if (state.onlyFavorites) {
        parts.push('åªçœ‹æ”¶è—');
      }
      taxStats.textContent = parts.length ? parts.join(' ï½œ ') : '';

      activeFilters.innerHTML = '';
      if (state.categoryKey) {
        const b = document.createElement('span');
        b.className = 'badge';
        b.textContent = `åˆ†é¡ï¼š${toZhCategory(state.categoryKey)}`;
        activeFilters.appendChild(b);
      }
      if (state.mechanismKey) {
        const b = document.createElement('span');
        b.className = 'badge';
        b.textContent = `æ©Ÿåˆ¶ï¼š${toZhMechanism(state.mechanismKey)}`;
        activeFilters.appendChild(b);
      }
      if (state.searchText.trim()) {
        const b = document.createElement('span');
        b.className = 'badge';
        b.textContent = `æœå°‹ï¼šã€Œ${state.searchText.trim()}ã€`;
        activeFilters.appendChild(b);
      }
      if (state.onlyFavorites) {
        const b = document.createElement('span');
        b.className = 'badge';
        b.textContent = 'åªçœ‹æ”¶è—';
        activeFilters.appendChild(b);
      }
    }

    function renderRandomPreview() {
      if (!randomSection) return;
      randomContainer.innerHTML = '';

      if (!randomVisible) {
        randomSection.classList.add('collapsed');
        return;
      }
      randomSection.classList.remove('collapsed');

      const n = Math.min(4, allGames.length);
      const picks = pickRandom(allGames, n);
      for (const g of picks) {
        const card = createGameCard(g, {compact: true, clickable: true});
        randomContainer.appendChild(card);
      }
    }

    function renderCards() {
      cardsContainer.innerHTML = '';
      const pageSize = state.pageSize;
      const total = filteredGames.length;
      const pageCount = Math.max(1, Math.ceil(total / pageSize));
      const pageIndex = Math.min(state.currentPage, pageCount - 1);
      state.currentPage = pageIndex;

      const start = pageIndex * pageSize;
      const end = Math.min(start + pageSize, total);
      const slice = filteredGames.slice(start, end);

      for (const g of slice) {
        const card = createGameCard(g, {compact: false, clickable: true});
        cardsContainer.appendChild(card);
      }

      pageInfo.textContent =
        `ç¬¬ ${pageIndex + 1} / ${pageCount} é ï¼ˆé¡¯ç¤ºç¬¬ ${start + 1}â€“${end} ç­†ï¼‰`;

      prevPageBtn.disabled = pageIndex === 0;
      nextPageBtn.disabled = pageIndex >= pageCount - 1;
    }

    function createGameCard(game, {compact, clickable}) {
      const card = document.createElement('article');
      card.className = 'card';

      const imgWrap = document.createElement('div');
      imgWrap.className = 'card-img-wrapper';
      const img = document.createElement('img');
      img.className = 'card-img';
      img.src = game.image || '';
      img.alt = game.nameZh || game.nameEn || '';
      img.loading = 'lazy';
      img.onerror = () => {
        img.style.display = 'none';
      };
      imgWrap.appendChild(img);
      card.appendChild(imgWrap);

      const body = document.createElement('div');
      body.className = 'card-body';

      const title = document.createElement('div');
      title.className = 'card-title';
      title.textContent = game.nameZh || game.nameEn || '(æœªå‘½å)';
      body.appendChild(title);

      const subtitle = document.createElement('div');
      subtitle.className = 'card-subtitle';
      const parts = [];
      if (game.ratingBayes != null || game.ratingAvg != null) {
        parts.push(`Bayesï¼š${formatNumber(game.ratingBayes)}ï¼å‡åˆ†ï¼š${formatNumber(game.ratingAvg)}`);
      }
      if (game.usersRated != null) {
        parts.push(`è©•åˆ†äººæ•¸ï¼š${game.usersRated}`);
      }
      if (game.year) {
        parts.push(`å‡ºç‰ˆï¼š${game.year}`);
      }
      subtitle.textContent = parts.join(' ï½œ ');
      body.appendChild(subtitle);

      const metaRow = document.createElement('div');
      metaRow.className = 'meta-row';

      const pTag = document.createElement('span');
      pTag.className = 'meta-tag';
      pTag.innerHTML = `<strong>äººæ•¸ï¼š</strong>${formatRange(game.minPlayers, game.maxPlayers, 'äºº')}`;
      metaRow.appendChild(pTag);

      const tTag = document.createElement('span');
      tTag.className = 'meta-tag';
      tTag.innerHTML = `<strong>æ™‚é–“ï¼š</strong>${formatRange(game.minPlaytime, game.maxPlaytime, 'åˆ†')}`;
      metaRow.appendChild(tTag);

      const wTag = document.createElement('span');
      wTag.className = 'meta-tag';
      wTag.innerHTML = `<strong>é‡é‡ï¼š</strong>${formatNumber(game.weight)}`;
      metaRow.appendChild(wTag);

      const mTag = document.createElement('span');
      mTag.className = 'meta-tag';
      mTag.innerHTML = `<strong>æ©Ÿåˆ¶æ•¸ï¼š</strong>${game.mechanismCount ?? '-'}`;
      metaRow.appendChild(mTag);

      body.appendChild(metaRow);

      const chipsRow = document.createElement('div');
      chipsRow.className = 'chips-row';

      game.categories.forEach(c => {
        const chip = document.createElement('button');
        chip.type = 'button';
        chip.className = 'chip';
        chip.textContent = toZhCategory(c);
        chip.title = c;
        chip.addEventListener('click', (ev) => {
          ev.stopPropagation();
          state.categoryKey = c;
          categorySelect.value = c;
          applyFilters();
        });
        chipsRow.appendChild(chip);
      });

      game.mechanisms.forEach(m => {
        const chip = document.createElement('button');
        chip.type = 'button';
        chip.className = 'chip';
        chip.textContent = toZhMechanism(m);
        chip.title = m;
        chip.addEventListener('click', (ev) => {
          ev.stopPropagation();
          state.mechanismKey = m;
          mechanismSelect.value = m;
          applyFilters();
        });
        chipsRow.appendChild(chip);
      });

      body.appendChild(chipsRow);

      const priceStock = document.createElement('div');
      priceStock.className = 'price-stock';

      const price = document.createElement('div');
      price.className = 'price';
      price.textContent = game.price != null ? `äºŒæ‰‹ï¼šNT$${game.price}` : 'åƒ¹æ ¼æœªè¨­å®š';
      priceStock.appendChild(price);

      const stock = document.createElement('div');
      stock.className = 'stock';
      if (game.stock == null) {
        stock.textContent = '';
      } else if (game.stock <= 0) {
        stock.textContent = 'åº«å­˜ï¼šå”®å®Œ';
        stock.classList.add('stock-zero');
      } else {
        stock.textContent = `åº«å­˜ï¼š${game.stock}`;
      }
      priceStock.appendChild(stock);

      body.appendChild(priceStock);

      card.appendChild(body);

      const footer = document.createElement('div');
      footer.className = 'card-footer';

      const left = document.createElement('div');
      left.textContent = '';
      footer.appendChild(left);

      const btns = document.createElement('div');
      btns.className = 'footer-buttons';

      const favBtn = document.createElement('button');
      favBtn.type = 'button';
      favBtn.className = 'btn-ghost';
      if (favoriteIds.has(game.id)) {
        favBtn.classList.add('is-fav');
        favBtn.textContent = 'â˜… å·²æ”¶è—';
      } else {
        favBtn.textContent = 'â˜† æ”¶è—';
      }
      favBtn.addEventListener('click', (ev) => {
        ev.stopPropagation();
        if (favoriteIds.has(game.id)) {
          favoriteIds.delete(game.id);
        } else {
          favoriteIds.add(game.id);
        }
        saveFavorites();
        if (favoriteIds.has(game.id)) {
          favBtn.classList.add('is-fav');
          favBtn.textContent = 'â˜… å·²æ”¶è—';
        } else {
          favBtn.classList.remove('is-fav');
          favBtn.textContent = 'â˜† æ”¶è—';
        }
        if (state.onlyFavorites) {
          applyFilters();
        }
      });
      btns.appendChild(favBtn);

      if (game.bggUrl) {
        const bggLink = document.createElement('a');
        bggLink.className = 'btn-link';
        bggLink.href = game.bggUrl;
        bggLink.target = '_blank';
        bggLink.rel = 'noopener noreferrer';
        bggLink.textContent = 'BGG';
        bggLink.addEventListener('click', (ev) => {
          ev.stopPropagation();
        });
        btns.appendChild(bggLink);
      }

      footer.appendChild(btns);
      card.appendChild(footer);

      if (clickable) {
        card.addEventListener('click', () => {
          openModalForGame(game);
        });
      }

      if (compact) {
        card.style.fontSize = '0.74rem';
      }

      return card;
    }

    function pickRandom(list, n) {
      const copy = [...list];
      for (let i = copy.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [copy[i], copy[j]] = [copy[j], copy[i]];
      }
      return copy.slice(0, n);
    }

    function computeSimilarGames(baseGame, maxCount) {
      const baseCats = new Set(baseGame.categories);
      const baseMechs = new Set(baseGame.mechanisms);
      const baseWeight = baseGame.weight;

      const scored = [];
      for (const g of allGames) {
        if (g.id === baseGame.id) continue;

        let score = 0;
        g.categories.forEach(c => { if (baseCats.has(c)) score += 2; });
        g.mechanisms.forEach(m => { if (baseMechs.has(m)) score += 3; });

        if (baseWeight != null && g.weight != null) {
          score -= Math.abs(baseWeight - g.weight);
        }

        scored.push({ game: g, score });
      }

      scored.sort((a, b) => b.score - a.score);
      let picked = scored.filter(s => s.score > 0).slice(0, maxCount);

      if (picked.length < 5) {
        const used = new Set(picked.map(p => p.game.id));
        for (const s of scored) {
          if (picked.length >= maxCount) break;
          if (used.has(s.game.id)) continue;
          picked.push(s);
          used.add(s.game.id);
        }
      }

      return picked.slice(0, maxCount).map(p => p.game);
    }

    function formatNumber(x) {
      if (x == null || Number.isNaN(x)) return '-';
      const n = Number(x);
      if (!Number.isFinite(n)) return '-';
      return n.toFixed(2);
    }

    function formatRange(min, max, unit) {
      if (min == null && max == null) return '-';
      if (min != null && max != null && min !== max) {
        return `${min}-${max}${unit}`;
      }
      const v = min != null ? min : max;
      return `${v}${unit}`;
    }

    // ===== Modal =====
    function openModalForGame(game) {
      focusGame = game;
      randomVisible = false;
      renderRandomPreview();

      if (!cardModal || !cardModalBody) return;
      cardModalBody.innerHTML = '';

      const title = document.createElement('h3');
      title.className = 'modal-title';
      title.textContent = game.nameZh || game.nameEn || '(æœªå‘½å)';
      cardModalBody.appendChild(title);

      const subtitle = document.createElement('p');
      subtitle.className = 'modal-subtitle';
      subtitle.textContent = 'è©³ç´°è³‡è¨Šèˆ‡ç›¸ä¼¼æ¨è–¦';
      cardModalBody.appendChild(subtitle);

      const focusCard = createGameCard(game, {compact: false, clickable: false});
      focusCard.classList.add('card-focus');
      cardModalBody.appendChild(focusCard);

      const secTitle = document.createElement('div');
      secTitle.className = 'modal-section-title';
      secTitle.textContent = 'ä½ å¯èƒ½ä¹Ÿæœƒå–œæ­¡';
      cardModalBody.appendChild(secTitle);

      const note = document.createElement('p');
      note.className = 'recommend-note';
      note.textContent = 'æ ¹æ“šåˆ†é¡èˆ‡æ©Ÿåˆ¶æŒ‘é¸ 5â€“8 æ¬¾ç›¸ä¼¼éŠæˆ²ã€‚';
      cardModalBody.appendChild(note);

      const sims = computeSimilarGames(game, 8);
      const grid = document.createElement('div');
      grid.className = 'recommend-grid';
      sims.forEach(g => {
        const card = createGameCard(g, {compact: true, clickable: true});
        grid.appendChild(card);
      });
      cardModalBody.appendChild(grid);

      cardModal.classList.add('show');
    }

    function closeModal() {
      if (!cardModal) return;
      cardModal.classList.remove('show');
    }

    function updateFavFilterBtn() {
      if (!favFilterBtn) return;
      if (state.onlyFavorites) {
        favFilterBtn.classList.add('btn-toggle-active');
        favFilterBtn.textContent = 'åªçœ‹æ”¶è—ï¼ˆé–‹ï¼‰';
      } else {
        favFilterBtn.classList.remove('btn-toggle-active');
        favFilterBtn.textContent = 'åªçœ‹æ”¶è—';
      }
    }

    function setupEvents() {
      searchInput.addEventListener('input', (e) => {
        state.searchText = e.target.value || '';
        applyFilters();
      });

      categorySelect.addEventListener('change', (e) => {
        state.categoryKey = e.target.value || '';
        applyFilters();
      });

      mechanismSelect.addEventListener('change', (e) => {
        state.mechanismKey = e.target.value || '';
        applyFilters();
      });

      sortSelect.addEventListener('change', (e) => {
        state.sortKey = e.target.value;
        applyFilters();
      });

      pageSizeSelect.addEventListener('change', (e) => {
        const v = parseInt(e.target.value, 10);
        state.pageSize = Number.isNaN(v) ? 25 : v;
        state.currentPage = 0;
        renderCards();
      });

      clearButton.addEventListener('click', () => {
        state.searchText = '';
        state.categoryKey = '';
        state.mechanismKey = '';
        state.sortKey = 'name_zh';
        state.pageSize = 25;
        state.currentPage = 0;
        state.onlyFavorites = false;

        searchInput.value = '';
        categorySelect.value = '';
        mechanismSelect.value = '';
        sortSelect.value = 'name_zh';
        pageSizeSelect.value = '25';
        updateFavFilterBtn();

        applyFilters();
      });

      randomButton.addEventListener('click', () => {
        randomVisible = true;
        renderRandomPreview();
      });

      if (favFilterBtn) {
        favFilterBtn.addEventListener('click', () => {
          state.onlyFavorites = !state.onlyFavorites;
          updateFavFilterBtn();
          applyFilters();
        });
      }

      prevPageBtn.addEventListener('click', () => {
        if (state.currentPage > 0) {
          state.currentPage -= 1;
          renderCards();
        }
      });

      nextPageBtn.addEventListener('click', () => {
        const total = filteredGames.length;
        const pageCount = Math.max(1, Math.ceil(total / state.pageSize));
        if (state.currentPage < pageCount - 1) {
          state.currentPage += 1;
          renderCards();
        }
      });

      if (downloadFavBtn) {
        downloadFavBtn.addEventListener('click', () => {
          downloadFavoritesAsCSV();
        });
      }

      if (cardModalClose) {
        cardModalClose.addEventListener('click', () => {
          closeModal();
        });
      }
      if (cardModal) {
        cardModal.addEventListener('click', (e) => {
          if (e.target === cardModal) {
            closeModal();
          }
        });
      }
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          closeModal();
        }
      });
    }

    function renderAll() {
      const { catMap, mechMap } = buildTaxonomy(allGames);
      renderStats(catMap, mechMap);
      renderRandomPreview();
      renderCards();
    }

    // ===== åˆå§‹åŒ– =====
    (async function init() {
      loadFavorites();

      await Promise.all([
        loadCsvMap('category', ['../data/category_map_zh.csv', 'data/category_map_zh.csv'], CATEGORY_ZH_MAP),
        loadCsvMap('mechanism', ['../data/mechanism_map_zh.csv', 'data/mechanism_map_zh.csv'], MECHANISM_ZH_MAP),
      ]);

      const raw = await fetchWithFallback();
      const list = Array.isArray(raw) ? raw : [];
      const used = filterByManualOverride(list);
      allGames = used.map(normalizeGame);

      const { catMap, mechMap } = buildTaxonomy(allGames);
      initFilterSelects(catMap, mechMap);
      setupEvents();
      updateFavFilterBtn();

      sortGames(allGames, state.sortKey);
      filteredGames = [...allGames];
      renderAll();
    })();
  </script>
</body>
</html>
